webpackHotUpdate_N_E("pages/project/[id]",{

/***/ "./node_modules/next/dist/compiled/webpack/module.js":
false,

/***/ "./node_modules/react-smooth-scroll-hook/dist/react-smooth-scroll-hook.esm.js":
/*!************************************************************************************!*\
  !*** ./node_modules/react-smooth-scroll-hook/dist/react-smooth-scroll-hook.esm.js ***!
  \************************************************************************************/
/*! exports provided: default, useScrollWatch, useSmoothScroll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useScrollWatch\", function() { return useScrollWatch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useSmoothScroll\", function() { return useSmoothScroll; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nvar Direction;\n\n(function (Direction) {\n  Direction[\"X\"] = \"x\";\n  Direction[\"Y\"] = \"y\";\n})(Direction || (Direction = {}));\n\nvar getAttrMap = function getAttrMap(direction) {\n  return {\n    leftTop: Direction.X === direction ? 'left' : 'top',\n    offsetLeftTop: Direction.X === direction ? 'offsetLeft' : 'offsetTop',\n    offsetWidthHeight: Direction.X === direction ? 'offsetWidth' : 'offsetHeight',\n    scrollLeftTop: Direction.X === direction ? 'scrollLeft' : 'scrollTop',\n    scrollWidthHeight: Direction.X === direction ? 'scrollWidth' : 'scrollHeight',\n    clientWidthHeight: Direction.X === direction ? 'clientWidth' : 'clientHeight'\n  };\n};\nfunction debounce(cb, delay) {\n  if (delay === void 0) {\n    delay = 100;\n  }\n\n  var timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    var _this = this;\n\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(function () {\n      cb.apply(_this, args);\n    }, delay);\n  };\n} // judge body or documentElement\n\nvar isWindowScrollParent = function isWindowScrollParent(elm) {\n  return !elm.parentElement || !elm.parentElement.parentElement;\n};\n\nvar getRelativeDistance = function getRelativeDistance(target, parent, attrMap) {\n  if (typeof target === 'number') return target;\n\n  if (typeof target === 'string') {\n    var elm = document.querySelector(target);\n\n    if (!elm) {\n      console.warn('Please pass correct selector string for scrollTo()!');\n      return 0;\n    }\n\n    var dis = 0; // if parent is document.documentElement or document.body\n\n    if (isWindowScrollParent(parent)) {\n      dis = elm.getBoundingClientRect()[attrMap.leftTop];\n    } else {\n      dis = elm.getBoundingClientRect()[attrMap.leftTop] - parent.getBoundingClientRect()[attrMap.leftTop];\n    }\n\n    return dis;\n  }\n\n  return 0;\n};\nvar useSmoothScroll = function useSmoothScroll(_ref) {\n  var ref = _ref.ref,\n      _ref$speed = _ref.speed,\n      speed = _ref$speed === void 0 ? 100 : _ref$speed,\n      _ref$direction = _ref.direction,\n      direction = _ref$direction === void 0 ? Direction.Y : _ref$direction,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? 1 : _ref$threshold;\n  var attrMap = getAttrMap(direction);\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(true),\n      reachedTop = _useState[0],\n      setReachedTop = _useState[1];\n\n  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(true),\n      reachedBottom = _useState2[0],\n      setReachedBottom = _useState2[1];\n\n  var _useState3 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(0),\n      size = _useState3[0],\n      setSize = _useState3[1];\n\n  var isTopEdge = function isTopEdge() {\n    var elm = ref.current;\n    if (!elm) return false;\n    return elm[attrMap.scrollLeftTop] === 0;\n  };\n\n  var isBottomEdge = function isBottomEdge() {\n    var elm = ref.current;\n    if (!elm) return false;\n    return Math.abs(elm[attrMap.scrollLeftTop] + elm[attrMap.clientWidthHeight] - elm[attrMap.scrollWidthHeight]) < threshold;\n  };\n\n  var refreshSize = debounce(function () {\n    if (ref.current) {\n      var _size = ref.current[attrMap.clientWidthHeight];\n      setSize(_size);\n    }\n  });\n  var refreshState = debounce(function (_evt) {\n    isTopEdge() ? setReachedTop(true) : setReachedTop(false);\n    isBottomEdge() ? setReachedBottom(true) : setReachedBottom(false);\n  });\n\n  var scrollTo = function scrollTo(target, offset) {\n    if (!ref || !ref.current) {\n      console.warn('Please pass `ref` property for your scroll container! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook');\n      return;\n    }\n\n    var elm = ref.current;\n    if (!elm) return;\n\n    if (!target && typeof target !== 'number') {\n      console.warn('Please pass a valid property for `scrollTo()`! \\n Get more info at https://github.com/ron0115/react-smooth-scroll-hook');\n    }\n\n    var initScrollLeftTop = elm[attrMap.scrollLeftTop];\n    var distance = getRelativeDistance(target, elm, attrMap); // set a offset\n\n    if (typeof offset === 'number') {\n      distance += offset;\n    }\n\n    var _speed = speed;\n\n    var cb = function cb() {\n      refreshState();\n      if (distance === 0) return;\n      if (isBottomEdge() && distance > 9 || distance < 0 && isTopEdge()) return;\n\n      var gone = function gone() {\n        return Math.abs(elm[attrMap.scrollLeftTop] - initScrollLeftTop);\n      };\n\n      if (Math.abs(distance) - gone() < _speed) {\n        _speed = Math.abs(distance) - gone();\n      } // distance to run every frame，always 1/60s\n\n\n      elm[attrMap.scrollLeftTop] += _speed * (distance > 0 ? 1 : -1); // reach destination, threshold defaults to 1\n\n      if (Math.abs(gone() - Math.abs(distance)) < threshold) {\n        return;\n      }\n\n      requestAnimationFrame(cb);\n    };\n\n    requestAnimationFrame(cb);\n  }; // detect dom changes\n\n\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    if (!ref.current) return;\n    refreshState();\n    refreshSize();\n    var observer = new MutationObserver(function (mutationsList, _observer) {\n      // Use traditional 'for loops' for IE 11\n      for (var _iterator = _createForOfIteratorHelperLoose(mutationsList), _step; !(_step = _iterator()).done;) {\n        var mutation = _step.value;\n\n        if (mutation.type === 'attributes' && mutation.target instanceof Element) {\n          refreshSize();\n        }\n      }\n    });\n    observer.observe(ref.current, {\n      attributes: true\n    });\n    window.addEventListener('resize', refreshSize);\n    return function () {\n      observer.disconnect();\n      window.removeEventListener('resize', refreshSize);\n    };\n  }, [ref, refreshState, refreshSize]); // detect scrollbar changes\n\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    if (!ref.current) return;\n    var elm = ref.current;\n    var observer = new MutationObserver(function (mutationsList, _observer) {\n      // Use traditional 'for loops' for IE 11\n      for (var _iterator2 = _createForOfIteratorHelperLoose(mutationsList), _step2; !(_step2 = _iterator2()).done;) {\n        var mutation = _step2.value;\n\n        if (mutation.type === 'childList' && mutation.target instanceof Element) {\n          refreshState();\n        }\n      }\n    });\n    observer.observe(elm, {\n      childList: true,\n      subtree: true\n    });\n    elm.addEventListener('scroll', refreshState);\n    return function () {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refreshState);\n    };\n  }, [ref, refreshState]);\n  return {\n    reachedTop: reachedTop,\n    reachedBottom: reachedBottom,\n    containerSize: size,\n    scrollTo: scrollTo,\n\n    /** @deprecated replace with scrollTo(n * containerSize) */\n    scrollToPage: function scrollToPage(page) {\n      scrollTo(page * size);\n    },\n\n    /** @deprecated */\n    refreshState: refreshState,\n\n    /** @deprecated */\n    refreshSize: refreshSize\n  };\n};\n\nvar getCurIndex = function getCurIndex(scrollTop, list) {\n  var length = list.length;\n  if (!length) return -1;\n\n  for (var i = 0; i < length; i++) {\n    if (scrollTop < list[i]) {\n      return i - 1;\n    }\n  }\n\n  if (scrollTop >= list[length - 1]) {\n    return list.length - 1;\n  }\n\n  return -1;\n};\nvar useScrollWatch = function useScrollWatch(props) {\n  var ref = props.ref,\n      _props$list = props.list,\n      list = _props$list === void 0 ? [] : _props$list,\n      offset = props.offset,\n      _props$direction = props.direction,\n      direction = _props$direction === void 0 ? 'y' : _props$direction;\n  var attrMap = getAttrMap(direction);\n\n  var getScrollTop = function getScrollTop() {\n    var elm = ref.current;\n    if (!elm) return 0;\n    return elm[attrMap.scrollLeftTop];\n  };\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(getScrollTop() || 0),\n      scrollTop = _useState[0],\n      setScrollTop = _useState[1];\n\n  var getPosList = function getPosList() {\n    var posList = list.map(function (item) {\n      var parent = ref.current;\n      var os = typeof item.offset === 'number' ? item.offset : offset || 0;\n      var elm = document.querySelector(item.href);\n      if (!elm) return Infinity;\n      if (!parent) return Infinity;\n      return isWindowScrollParent(parent) ? elm.getBoundingClientRect()[attrMap.leftTop] - parent.getBoundingClientRect()[attrMap.leftTop] + os : elm.getBoundingClientRect()[attrMap.leftTop] - parent.children[0].getBoundingClientRect()[attrMap.leftTop] + os;\n    });\n    return posList;\n  };\n\n  var refresh = debounce(function () {\n    setScrollTop(getScrollTop());\n    setPosList(getPosList());\n  }, 100);\n\n  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])([]),\n      posList = _useState2[0],\n      setPosList = _useState2[1];\n\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    refresh();\n  }, [ref, refresh]);\n  var curIndex = getCurIndex(scrollTop, posList);\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    if (!ref.current) return;\n    var elm = isWindowScrollParent(ref.current) ? window : ref.current;\n    var observer = new window.MutationObserver(refresh);\n    observer.observe(ref.current, {\n      childList: true,\n      subtree: true\n    });\n    elm.addEventListener('scroll', refresh);\n    return function () {\n      observer.disconnect();\n      elm && elm.removeEventListener('scroll', refresh);\n    };\n  }, [ref, refresh]);\n  return {\n    curIndex: curIndex,\n    scrollTop: scrollTop,\n    curItem: list[curIndex] || {}\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (useSmoothScroll);\n\n//# sourceMappingURL=react-smooth-scroll-hook.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNtb290aC1zY3JvbGwtaG9vay9kaXN0L3JlYWN0LXNtb290aC1zY3JvbGwtaG9vay5lc20uanM/NWZiNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNEQUFRO0FBQzFCO0FBQ0E7O0FBRUEsbUJBQW1CLHNEQUFRO0FBQzNCO0FBQ0E7O0FBRUEsbUJBQW1CLHNEQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0osRUFBRSx1REFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNkJBQTZCO0FBQzlHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0NBQW9DOztBQUV2QyxFQUFFLHVEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsK0JBQStCO0FBQ2xIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0RBQVE7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxtQkFBbUIsc0RBQVE7QUFDM0I7QUFDQTs7QUFFQSxFQUFFLHVEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLHVEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLDhFQUFlLEVBQUM7QUFDWTtBQUMzQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1zbW9vdGgtc2Nyb2xsLWhvb2svZGlzdC9yZWFjdC1zbW9vdGgtc2Nyb2xsLWhvb2suZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxudmFyIERpcmVjdGlvbjtcblxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgRGlyZWN0aW9uW1wiWFwiXSA9IFwieFwiO1xuICBEaXJlY3Rpb25bXCJZXCJdID0gXCJ5XCI7XG59KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5cbnZhciBnZXRBdHRyTWFwID0gZnVuY3Rpb24gZ2V0QXR0ck1hcChkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0VG9wOiBEaXJlY3Rpb24uWCA9PT0gZGlyZWN0aW9uID8gJ2xlZnQnIDogJ3RvcCcsXG4gICAgb2Zmc2V0TGVmdFRvcDogRGlyZWN0aW9uLlggPT09IGRpcmVjdGlvbiA/ICdvZmZzZXRMZWZ0JyA6ICdvZmZzZXRUb3AnLFxuICAgIG9mZnNldFdpZHRoSGVpZ2h0OiBEaXJlY3Rpb24uWCA9PT0gZGlyZWN0aW9uID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnLFxuICAgIHNjcm9sbExlZnRUb3A6IERpcmVjdGlvbi5YID09PSBkaXJlY3Rpb24gPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJyxcbiAgICBzY3JvbGxXaWR0aEhlaWdodDogRGlyZWN0aW9uLlggPT09IGRpcmVjdGlvbiA/ICdzY3JvbGxXaWR0aCcgOiAnc2Nyb2xsSGVpZ2h0JyxcbiAgICBjbGllbnRXaWR0aEhlaWdodDogRGlyZWN0aW9uLlggPT09IGRpcmVjdGlvbiA/ICdjbGllbnRXaWR0aCcgOiAnY2xpZW50SGVpZ2h0J1xuICB9O1xufTtcbmZ1bmN0aW9uIGRlYm91bmNlKGNiLCBkZWxheSkge1xuICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgIGRlbGF5ID0gMTAwO1xuICB9XG5cbiAgdmFyIHRpbWVyO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1pZ25vcmVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aW1lcikgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2IuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn0gLy8ganVkZ2UgYm9keSBvciBkb2N1bWVudEVsZW1lbnRcblxudmFyIGlzV2luZG93U2Nyb2xsUGFyZW50ID0gZnVuY3Rpb24gaXNXaW5kb3dTY3JvbGxQYXJlbnQoZWxtKSB7XG4gIHJldHVybiAhZWxtLnBhcmVudEVsZW1lbnQgfHwgIWVsbS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG59O1xuXG52YXIgZ2V0UmVsYXRpdmVEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFJlbGF0aXZlRGlzdGFuY2UodGFyZ2V0LCBwYXJlbnQsIGF0dHJNYXApIHtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSByZXR1cm4gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBlbG0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICBpZiAoIWVsbSkge1xuICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgcGFzcyBjb3JyZWN0IHNlbGVjdG9yIHN0cmluZyBmb3Igc2Nyb2xsVG8oKSEnKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBkaXMgPSAwOyAvLyBpZiBwYXJlbnQgaXMgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IG9yIGRvY3VtZW50LmJvZHlcblxuICAgIGlmIChpc1dpbmRvd1Njcm9sbFBhcmVudChwYXJlbnQpKSB7XG4gICAgICBkaXMgPSBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbYXR0ck1hcC5sZWZ0VG9wXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzID0gZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2F0dHJNYXAubGVmdFRvcF0gLSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbYXR0ck1hcC5sZWZ0VG9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xudmFyIHVzZVNtb290aFNjcm9sbCA9IGZ1bmN0aW9uIHVzZVNtb290aFNjcm9sbChfcmVmKSB7XG4gIHZhciByZWYgPSBfcmVmLnJlZixcbiAgICAgIF9yZWYkc3BlZWQgPSBfcmVmLnNwZWVkLFxuICAgICAgc3BlZWQgPSBfcmVmJHNwZWVkID09PSB2b2lkIDAgPyAxMDAgOiBfcmVmJHNwZWVkLFxuICAgICAgX3JlZiRkaXJlY3Rpb24gPSBfcmVmLmRpcmVjdGlvbixcbiAgICAgIGRpcmVjdGlvbiA9IF9yZWYkZGlyZWN0aW9uID09PSB2b2lkIDAgPyBEaXJlY3Rpb24uWSA6IF9yZWYkZGlyZWN0aW9uLFxuICAgICAgX3JlZiR0aHJlc2hvbGQgPSBfcmVmLnRocmVzaG9sZCxcbiAgICAgIHRocmVzaG9sZCA9IF9yZWYkdGhyZXNob2xkID09PSB2b2lkIDAgPyAxIDogX3JlZiR0aHJlc2hvbGQ7XG4gIHZhciBhdHRyTWFwID0gZ2V0QXR0ck1hcChkaXJlY3Rpb24pO1xuXG4gIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh0cnVlKSxcbiAgICAgIHJlYWNoZWRUb3AgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRSZWFjaGVkVG9wID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUyID0gdXNlU3RhdGUodHJ1ZSksXG4gICAgICByZWFjaGVkQm90dG9tID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFJlYWNoZWRCb3R0b20gPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gdXNlU3RhdGUoMCksXG4gICAgICBzaXplID0gX3VzZVN0YXRlM1swXSxcbiAgICAgIHNldFNpemUgPSBfdXNlU3RhdGUzWzFdO1xuXG4gIHZhciBpc1RvcEVkZ2UgPSBmdW5jdGlvbiBpc1RvcEVkZ2UoKSB7XG4gICAgdmFyIGVsbSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghZWxtKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGVsbVthdHRyTWFwLnNjcm9sbExlZnRUb3BdID09PSAwO1xuICB9O1xuXG4gIHZhciBpc0JvdHRvbUVkZ2UgPSBmdW5jdGlvbiBpc0JvdHRvbUVkZ2UoKSB7XG4gICAgdmFyIGVsbSA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghZWxtKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIE1hdGguYWJzKGVsbVthdHRyTWFwLnNjcm9sbExlZnRUb3BdICsgZWxtW2F0dHJNYXAuY2xpZW50V2lkdGhIZWlnaHRdIC0gZWxtW2F0dHJNYXAuc2Nyb2xsV2lkdGhIZWlnaHRdKSA8IHRocmVzaG9sZDtcbiAgfTtcblxuICB2YXIgcmVmcmVzaFNpemUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICB2YXIgX3NpemUgPSByZWYuY3VycmVudFthdHRyTWFwLmNsaWVudFdpZHRoSGVpZ2h0XTtcbiAgICAgIHNldFNpemUoX3NpemUpO1xuICAgIH1cbiAgfSk7XG4gIHZhciByZWZyZXNoU3RhdGUgPSBkZWJvdW5jZShmdW5jdGlvbiAoX2V2dCkge1xuICAgIGlzVG9wRWRnZSgpID8gc2V0UmVhY2hlZFRvcCh0cnVlKSA6IHNldFJlYWNoZWRUb3AoZmFsc2UpO1xuICAgIGlzQm90dG9tRWRnZSgpID8gc2V0UmVhY2hlZEJvdHRvbSh0cnVlKSA6IHNldFJlYWNoZWRCb3R0b20oZmFsc2UpO1xuICB9KTtcblxuICB2YXIgc2Nyb2xsVG8gPSBmdW5jdGlvbiBzY3JvbGxUbyh0YXJnZXQsIG9mZnNldCkge1xuICAgIGlmICghcmVmIHx8ICFyZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgcGFzcyBgcmVmYCBwcm9wZXJ0eSBmb3IgeW91ciBzY3JvbGwgY29udGFpbmVyISBcXG4gR2V0IG1vcmUgaW5mbyBhdCBodHRwczovL2dpdGh1Yi5jb20vcm9uMDExNS9yZWFjdC1zbW9vdGgtc2Nyb2xsLWhvb2snKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxtID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFlbG0pIHJldHVybjtcblxuICAgIGlmICghdGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSBwYXNzIGEgdmFsaWQgcHJvcGVydHkgZm9yIGBzY3JvbGxUbygpYCEgXFxuIEdldCBtb3JlIGluZm8gYXQgaHR0cHM6Ly9naXRodWIuY29tL3JvbjAxMTUvcmVhY3Qtc21vb3RoLXNjcm9sbC1ob29rJyk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRTY3JvbGxMZWZ0VG9wID0gZWxtW2F0dHJNYXAuc2Nyb2xsTGVmdFRvcF07XG4gICAgdmFyIGRpc3RhbmNlID0gZ2V0UmVsYXRpdmVEaXN0YW5jZSh0YXJnZXQsIGVsbSwgYXR0ck1hcCk7IC8vIHNldCBhIG9mZnNldFxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICBkaXN0YW5jZSArPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgdmFyIF9zcGVlZCA9IHNwZWVkO1xuXG4gICAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgICByZWZyZXNoU3RhdGUoKTtcbiAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkgcmV0dXJuO1xuICAgICAgaWYgKGlzQm90dG9tRWRnZSgpICYmIGRpc3RhbmNlID4gOSB8fCBkaXN0YW5jZSA8IDAgJiYgaXNUb3BFZGdlKCkpIHJldHVybjtcblxuICAgICAgdmFyIGdvbmUgPSBmdW5jdGlvbiBnb25lKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZWxtW2F0dHJNYXAuc2Nyb2xsTGVmdFRvcF0gLSBpbml0U2Nyb2xsTGVmdFRvcCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2UpIC0gZ29uZSgpIDwgX3NwZWVkKSB7XG4gICAgICAgIF9zcGVlZCA9IE1hdGguYWJzKGRpc3RhbmNlKSAtIGdvbmUoKTtcbiAgICAgIH0gLy8gZGlzdGFuY2UgdG8gcnVuIGV2ZXJ5IGZyYW1l77yMYWx3YXlzIDEvNjBzXG5cblxuICAgICAgZWxtW2F0dHJNYXAuc2Nyb2xsTGVmdFRvcF0gKz0gX3NwZWVkICogKGRpc3RhbmNlID4gMCA/IDEgOiAtMSk7IC8vIHJlYWNoIGRlc3RpbmF0aW9uLCB0aHJlc2hvbGQgZGVmYXVsdHMgdG8gMVxuXG4gICAgICBpZiAoTWF0aC5hYnMoZ29uZSgpIC0gTWF0aC5hYnMoZGlzdGFuY2UpKSA8IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gICAgfTtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG4gIH07IC8vIGRldGVjdCBkb20gY2hhbmdlc1xuXG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgcmVmcmVzaFN0YXRlKCk7XG4gICAgcmVmcmVzaFNpemUoKTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zTGlzdCwgX29ic2VydmVyKSB7XG4gICAgICAvLyBVc2UgdHJhZGl0aW9uYWwgJ2ZvciBsb29wcycgZm9yIElFIDExXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG11dGF0aW9uc0xpc3QpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICB2YXIgbXV0YXRpb24gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICByZWZyZXNoU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCwge1xuICAgICAgYXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZWZyZXNoU2l6ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZWZyZXNoU2l6ZSk7XG4gICAgfTtcbiAgfSwgW3JlZiwgcmVmcmVzaFN0YXRlLCByZWZyZXNoU2l6ZV0pOyAvLyBkZXRlY3Qgc2Nyb2xsYmFyIGNoYW5nZXNcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICB2YXIgZWxtID0gcmVmLmN1cnJlbnQ7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9uc0xpc3QsIF9vYnNlcnZlcikge1xuICAgICAgLy8gVXNlIHRyYWRpdGlvbmFsICdmb3IgbG9vcHMnIGZvciBJRSAxMVxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobXV0YXRpb25zTGlzdCksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBtdXRhdGlvbiA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcgJiYgbXV0YXRpb24udGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIHJlZnJlc2hTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbG0sIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgcmVmcmVzaFN0YXRlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgZWxtICYmIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCByZWZyZXNoU3RhdGUpO1xuICAgIH07XG4gIH0sIFtyZWYsIHJlZnJlc2hTdGF0ZV0pO1xuICByZXR1cm4ge1xuICAgIHJlYWNoZWRUb3A6IHJlYWNoZWRUb3AsXG4gICAgcmVhY2hlZEJvdHRvbTogcmVhY2hlZEJvdHRvbSxcbiAgICBjb250YWluZXJTaXplOiBzaXplLFxuICAgIHNjcm9sbFRvOiBzY3JvbGxUbyxcblxuICAgIC8qKiBAZGVwcmVjYXRlZCByZXBsYWNlIHdpdGggc2Nyb2xsVG8obiAqIGNvbnRhaW5lclNpemUpICovXG4gICAgc2Nyb2xsVG9QYWdlOiBmdW5jdGlvbiBzY3JvbGxUb1BhZ2UocGFnZSkge1xuICAgICAgc2Nyb2xsVG8ocGFnZSAqIHNpemUpO1xuICAgIH0sXG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICByZWZyZXNoU3RhdGU6IHJlZnJlc2hTdGF0ZSxcblxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHJlZnJlc2hTaXplOiByZWZyZXNoU2l6ZVxuICB9O1xufTtcblxudmFyIGdldEN1ckluZGV4ID0gZnVuY3Rpb24gZ2V0Q3VySW5kZXgoc2Nyb2xsVG9wLCBsaXN0KSB7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHJldHVybiAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNjcm9sbFRvcCA8IGxpc3RbaV0pIHtcbiAgICAgIHJldHVybiBpIC0gMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2Nyb2xsVG9wID49IGxpc3RbbGVuZ3RoIC0gMV0pIHtcbiAgICByZXR1cm4gbGlzdC5sZW5ndGggLSAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcbnZhciB1c2VTY3JvbGxXYXRjaCA9IGZ1bmN0aW9uIHVzZVNjcm9sbFdhdGNoKHByb3BzKSB7XG4gIHZhciByZWYgPSBwcm9wcy5yZWYsXG4gICAgICBfcHJvcHMkbGlzdCA9IHByb3BzLmxpc3QsXG4gICAgICBsaXN0ID0gX3Byb3BzJGxpc3QgPT09IHZvaWQgMCA/IFtdIDogX3Byb3BzJGxpc3QsXG4gICAgICBvZmZzZXQgPSBwcm9wcy5vZmZzZXQsXG4gICAgICBfcHJvcHMkZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX3Byb3BzJGRpcmVjdGlvbiA9PT0gdm9pZCAwID8gJ3knIDogX3Byb3BzJGRpcmVjdGlvbjtcbiAgdmFyIGF0dHJNYXAgPSBnZXRBdHRyTWFwKGRpcmVjdGlvbik7XG5cbiAgdmFyIGdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIGdldFNjcm9sbFRvcCgpIHtcbiAgICB2YXIgZWxtID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFlbG0pIHJldHVybiAwO1xuICAgIHJldHVybiBlbG1bYXR0ck1hcC5zY3JvbGxMZWZ0VG9wXTtcbiAgfTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZ2V0U2Nyb2xsVG9wKCkgfHwgMCksXG4gICAgICBzY3JvbGxUb3AgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRTY3JvbGxUb3AgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIGdldFBvc0xpc3QgPSBmdW5jdGlvbiBnZXRQb3NMaXN0KCkge1xuICAgIHZhciBwb3NMaXN0ID0gbGlzdC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBwYXJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgIHZhciBvcyA9IHR5cGVvZiBpdGVtLm9mZnNldCA9PT0gJ251bWJlcicgPyBpdGVtLm9mZnNldCA6IG9mZnNldCB8fCAwO1xuICAgICAgdmFyIGVsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaXRlbS5ocmVmKTtcbiAgICAgIGlmICghZWxtKSByZXR1cm4gSW5maW5pdHk7XG4gICAgICBpZiAoIXBhcmVudCkgcmV0dXJuIEluZmluaXR5O1xuICAgICAgcmV0dXJuIGlzV2luZG93U2Nyb2xsUGFyZW50KHBhcmVudCkgPyBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbYXR0ck1hcC5sZWZ0VG9wXSAtIHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVthdHRyTWFwLmxlZnRUb3BdICsgb3MgOiBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbYXR0ck1hcC5sZWZ0VG9wXSAtIHBhcmVudC5jaGlsZHJlblswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVthdHRyTWFwLmxlZnRUb3BdICsgb3M7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvc0xpc3Q7XG4gIH07XG5cbiAgdmFyIHJlZnJlc2ggPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgc2V0U2Nyb2xsVG9wKGdldFNjcm9sbFRvcCgpKTtcbiAgICBzZXRQb3NMaXN0KGdldFBvc0xpc3QoKSk7XG4gIH0sIDEwMCk7XG5cbiAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShbXSksXG4gICAgICBwb3NMaXN0ID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldFBvc0xpc3QgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmcmVzaCgpO1xuICB9LCBbcmVmLCByZWZyZXNoXSk7XG4gIHZhciBjdXJJbmRleCA9IGdldEN1ckluZGV4KHNjcm9sbFRvcCwgcG9zTGlzdCk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFyZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIHZhciBlbG0gPSBpc1dpbmRvd1Njcm9sbFBhcmVudChyZWYuY3VycmVudCkgPyB3aW5kb3cgOiByZWYuY3VycmVudDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIocmVmcmVzaCk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCByZWZyZXNoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgZWxtICYmIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCByZWZyZXNoKTtcbiAgICB9O1xuICB9LCBbcmVmLCByZWZyZXNoXSk7XG4gIHJldHVybiB7XG4gICAgY3VySW5kZXg6IGN1ckluZGV4LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wLFxuICAgIGN1ckl0ZW06IGxpc3RbY3VySW5kZXhdIHx8IHt9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1c2VTbW9vdGhTY3JvbGw7XG5leHBvcnQgeyB1c2VTY3JvbGxXYXRjaCwgdXNlU21vb3RoU2Nyb2xsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1zbW9vdGgtc2Nyb2xsLWhvb2suZXNtLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-smooth-scroll-hook/dist/react-smooth-scroll-hook.esm.js\n");

/***/ }),

/***/ "./pages/project/[id].tsx":
/*!********************************!*\
  !*** ./pages/project/[id].tsx ***!
  \********************************/
/*! exports provided: Demo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Demo\", function() { return Demo; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_smooth_scroll_hook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-smooth-scroll-hook */ \"./node_modules/react-smooth-scroll-hook/dist/react-smooth-scroll-hook.esm.js\");\n\n\n\nvar _jsxFileName = \"/Users/applestock/macbook-documents/siteen-restart/siteen-restart-frontend/pages/project/[id].tsx\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\n// import style from '../../styles/ProjectPage.module.sass'\n// // temp project bg\n// import projectBg from '../../images/wings_bg.jpg'\n// import projectLogo from '../../images/wings_logo.svg'\n// import projecCheckDown from '../../images/project_check_down.svg'\n// import { useRef } from 'react'\n// import useSmoothScroll from 'react-smooth-scroll-hook'\n// const ProjectPage = () => {\n//   const ref = useRef(document.documentElement)\n//   const { scrollTo } = useSmoothScroll({\n//     ref,\n//     speed: 100,\n//     direction: 'y'\n//   })\n//   const tasks = [\n//     'Розробити дизайн сайту.',\n//     'Підтримувати позиціонування і фірмовий стиль.',\n//     'Ознайомити потенційних клієнтів із проектом.',\n//     \"Ненав'язливо стимулювати відвідувачів на завантаження додатку.\",\n//     'Реалізувати зручну інструктію користування сервісом.',\n//     'Показати технологічність компанії.',\n//     \"Налагодити зворотний зв'язок з клієнтами.\",\n//     'Реалізувати функціонал сайту на ...',\n//     'Відфотографувати продукцію для подальшого упакування проекту.',\n//     'Відзняти промо-відео проекту.',\n//     'Створити контент-план просування Instagram сторінки.'\n//   ]\n//   return (\n//     <>\n//       <header\n//         style={{ backgroundImage: `url(${projectBg})` }}\n//         className={style.project_page_header}>\n//         <div className='container'>\n//           <div className={style.project_info}>\n//             <img src={projectLogo} alt={'Brand logo'} />\n//             <div className={style.project_type}>\n//               <h3>Упаковка бізнесу</h3>\n//               <p>\n//                 Landing Page проекту. Фотозйомка. Промо-відео. Ведення\n//                 соц-мереж.\n//               </p>\n//             </div>\n//           </div>\n//           <button onClick={() => scrollTo('#projectDataId')}>\n//             <img src={projecCheckDown} alt='projecCheckDown' />\n//           </button>\n//         </div>\n//       </header>\n//       <section id={'projectDataId'} className={style.project_data}>\n//         <div className='container'>\n//           <div className={style.about}>\n//             <h3>Про компанію</h3>\n//             <p>\n//               Студія артіхектури і дизайну інтер’єру Наталії Губиш у Львові.\n//               Компанія розробляє і реалізовує дизайн житлових та інших\n//               просторів, широко спеціалізується на функціональному інтер’єрі і\n//               надає свої послуги не лише у Львові, а у будь яку точку світу.\n//             </p>\n//           </div>\n//           <div className={style.tasks}>\n//             <h3>Задачі</h3>\n//             <ul>\n//               {tasks.map((t) => (\n//                 <li key={t}>· {t}</li>\n//               ))}\n//             </ul>\n//           </div>\n//           <div className={style.results}>\n//             <h3>Результати</h3>\n//             <ul>\n//               <li>\n//                 <a href='#'>hubysh.com</a>\n//               </li>\n//               <li>\n//                 <a href='#'>@natalihubysh</a>\n//               </li>\n//             </ul>\n//           </div>\n//         </div>\n//       </section>\n//     </>\n//   )\n// }\n// export default ProjectPage\n\n\nvar Demo = function Demo() {\n  _s();\n\n  // A custom scroll container\n  //   const ref = useRef(null)\n  // Also support document.body / document.documentElement, and you don't need to set a ref passing to jsx\n  var ref = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useRef\"])(document.body);\n\n  var _useSmoothScroll = Object(react_smooth_scroll_hook__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n    ref: ref,\n    speed: 100,\n    direction: 'y'\n  }),\n      scrollTo = _useSmoothScroll.scrollTo;\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"button\", {\n      onClick: function onClick() {\n        return scrollTo('#item-20');\n      },\n      children: \"scrollTo('#item-20')\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n      // if use custom scroll container, pass ref\n      ref: ref,\n      style: {\n        overflowY: 'scroll',\n        maxHeight: '200px'\n      },\n      children: Array(100).fill(null).map(function (_item, i) {\n        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {\n          id: \"item-\".concat(i),\n          children: [\"item-\", i]\n        }, i, true, {\n          fileName: _jsxFileName,\n          lineNumber: 119,\n          columnNumber: 13\n        }, _this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 7\n    }, _this)]\n  }, void 0, true);\n};\n\n_s(Demo, \"DmMVAnZrtzaFmKT55hYEEhJTmHM=\", false, function () {\n  return [react_smooth_scroll_hook__WEBPACK_IMPORTED_MODULE_2__[\"default\"]];\n});\n\n_c = Demo;\n\nvar _c;\n\n$RefreshReg$(_c, \"Demo\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvcHJvamVjdC8udHN4PzE0NDMiXSwibmFtZXMiOlsiRGVtbyIsInJlZiIsInVzZVJlZiIsImRvY3VtZW50IiwiYm9keSIsInVzZVNtb290aFNjcm9sbCIsInNwZWVkIiwiZGlyZWN0aW9uIiwic2Nyb2xsVG8iLCJvdmVyZmxvd1kiLCJtYXhIZWlnaHQiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJfaXRlbSIsImkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNPLElBQU1BLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQU07QUFBQTs7QUFDeEI7QUFDRjtBQUVFO0FBQ0EsTUFBTUMsR0FBRyxHQUFHQyxvREFBTSxDQUFDQyxRQUFRLENBQUNDLElBQVYsQ0FBbEI7O0FBTHdCLHlCQU9IQyx3RUFBZSxDQUFDO0FBQ25DSixPQUFHLEVBQUhBLEdBRG1DO0FBRW5DSyxTQUFLLEVBQUUsR0FGNEI7QUFHbkNDLGFBQVMsRUFBRTtBQUh3QixHQUFELENBUFo7QUFBQSxNQU9oQkMsUUFQZ0Isb0JBT2hCQSxRQVBnQjs7QUFheEIsc0JBQ0U7QUFBQSw0QkFDRTtBQUFRLGFBQU8sRUFBRTtBQUFBLGVBQU1BLFFBQVEsQ0FBQyxVQUFELENBQWQ7QUFBQSxPQUFqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQURGLGVBRUU7QUFDRTtBQUNBLFNBQUcsRUFBRVAsR0FGUDtBQUdFLFdBQUssRUFBRTtBQUNMUSxpQkFBUyxFQUFFLFFBRE47QUFFTEMsaUJBQVMsRUFBRTtBQUZOLE9BSFQ7QUFBQSxnQkFPR0MsS0FBSyxDQUFDLEdBQUQsQ0FBTCxDQUNFQyxJQURGLENBQ08sSUFEUCxFQUVFQyxHQUZGLENBRU0sVUFBQ0MsS0FBRCxFQUFRQyxDQUFSO0FBQUEsNEJBQ0g7QUFBYSxZQUFFLGlCQUFVQSxDQUFWLENBQWY7QUFBQSw4QkFDUUEsQ0FEUjtBQUFBLFdBQVVBLENBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFERztBQUFBLE9BRk47QUFQSDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRkY7QUFBQSxrQkFERjtBQW9CRCxDQWpDTTs7R0FBTWYsSTtVQU9VSyxnRTs7O0tBUFZMLEkiLCJmaWxlIjoiLi9wYWdlcy9wcm9qZWN0L1tpZF0udHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHN0eWxlIGZyb20gJy4uLy4uL3N0eWxlcy9Qcm9qZWN0UGFnZS5tb2R1bGUuc2Fzcydcbi8vIC8vIHRlbXAgcHJvamVjdCBiZ1xuLy8gaW1wb3J0IHByb2plY3RCZyBmcm9tICcuLi8uLi9pbWFnZXMvd2luZ3NfYmcuanBnJ1xuLy8gaW1wb3J0IHByb2plY3RMb2dvIGZyb20gJy4uLy4uL2ltYWdlcy93aW5nc19sb2dvLnN2Zydcbi8vIGltcG9ydCBwcm9qZWNDaGVja0Rvd24gZnJvbSAnLi4vLi4vaW1hZ2VzL3Byb2plY3RfY2hlY2tfZG93bi5zdmcnXG4vLyBpbXBvcnQgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbi8vIGltcG9ydCB1c2VTbW9vdGhTY3JvbGwgZnJvbSAncmVhY3Qtc21vb3RoLXNjcm9sbC1ob29rJ1xuXG4vLyBjb25zdCBQcm9qZWN0UGFnZSA9ICgpID0+IHtcbi8vICAgY29uc3QgcmVmID0gdXNlUmVmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcblxuLy8gICBjb25zdCB7IHNjcm9sbFRvIH0gPSB1c2VTbW9vdGhTY3JvbGwoe1xuLy8gICAgIHJlZixcbi8vICAgICBzcGVlZDogMTAwLFxuLy8gICAgIGRpcmVjdGlvbjogJ3knXG4vLyAgIH0pXG5cbi8vICAgY29uc3QgdGFza3MgPSBbXG4vLyAgICAgJ9Cg0L7Qt9GA0L7QsdC40YLQuCDQtNC40LfQsNC50L0g0YHQsNC50YLRgy4nLFxuLy8gICAgICfQn9GW0LTRgtGA0LjQvNGD0LLQsNGC0Lgg0L/QvtC30LjRhtGW0L7QvdGD0LLQsNC90L3RjyDRliDRhNGW0YDQvNC+0LLQuNC5INGB0YLQuNC70YwuJyxcbi8vICAgICAn0J7Qt9C90LDQudC+0LzQuNGC0Lgg0L/QvtGC0LXQvdGG0ZbQudC90LjRhSDQutC70ZbRlNC90YLRltCyINGW0Lcg0L/RgNC+0LXQutGC0L7QvC4nLFxuLy8gICAgIFwi0J3QtdC90LDQsifRj9C30LvQuNCy0L4g0YHRgtC40LzRg9C70Y7QstCw0YLQuCDQstGW0LTQstGW0LTRg9Cy0LDRh9GW0LIg0L3QsCDQt9Cw0LLQsNC90YLQsNC20LXQvdC90Y8g0LTQvtC00LDRgtC60YMuXCIsXG4vLyAgICAgJ9Cg0LXQsNC70ZbQt9GD0LLQsNGC0Lgg0LfRgNGD0YfQvdGDINGW0L3RgdGC0YDRg9C60YLRltGOINC60L7RgNC40YHRgtGD0LLQsNC90L3RjyDRgdC10YDQstGW0YHQvtC8LicsXG4vLyAgICAgJ9Cf0L7QutCw0LfQsNGC0Lgg0YLQtdGF0L3QvtC70L7Qs9GW0YfQvdGW0YHRgtGMINC60L7QvNC/0LDQvdGW0ZcuJyxcbi8vICAgICBcItCd0LDQu9Cw0LPQvtC00LjRgtC4INC30LLQvtGA0L7RgtC90LjQuSDQt9CyJ9GP0LfQvtC6INC3INC60LvRltGU0L3RgtCw0LzQuC5cIixcbi8vICAgICAn0KDQtdCw0LvRltC30YPQstCw0YLQuCDRhNGD0L3QutGG0ZbQvtC90LDQuyDRgdCw0LnRgtGDINC90LAgLi4uJyxcbi8vICAgICAn0JLRltC00YTQvtGC0L7Qs9GA0LDRhNGD0LLQsNGC0Lgg0L/RgNC+0LTRg9C60YbRltGOINC00LvRjyDQv9C+0LTQsNC70YzRiNC+0LPQviDRg9C/0LDQutGD0LLQsNC90L3RjyDQv9GA0L7QtdC60YLRgy4nLFxuLy8gICAgICfQktGW0LTQt9C90Y/RgtC4INC/0YDQvtC80L4t0LLRltC00LXQviDQv9GA0L7QtdC60YLRgy4nLFxuLy8gICAgICfQodGC0LLQvtGA0LjRgtC4INC60L7QvdGC0LXQvdGCLdC/0LvQsNC9INC/0YDQvtGB0YPQstCw0L3QvdGPIEluc3RhZ3JhbSDRgdGC0L7RgNGW0L3QutC4Lidcbi8vICAgXVxuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPD5cbi8vICAgICAgIDxoZWFkZXJcbi8vICAgICAgICAgc3R5bGU9e3sgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7cHJvamVjdEJnfSlgIH19XG4vLyAgICAgICAgIGNsYXNzTmFtZT17c3R5bGUucHJvamVjdF9wYWdlX2hlYWRlcn0+XG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdjb250YWluZXInPlxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS5wcm9qZWN0X2luZm99PlxuLy8gICAgICAgICAgICAgPGltZyBzcmM9e3Byb2plY3RMb2dvfSBhbHQ9eydCcmFuZCBsb2dvJ30gLz5cbi8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS5wcm9qZWN0X3R5cGV9PlxuLy8gICAgICAgICAgICAgICA8aDM+0KPQv9Cw0LrQvtCy0LrQsCDQsdGW0LfQvdC10YHRgzwvaDM+XG4vLyAgICAgICAgICAgICAgIDxwPlxuLy8gICAgICAgICAgICAgICAgIExhbmRpbmcgUGFnZSDQv9GA0L7QtdC60YLRgy4g0KTQvtGC0L7Qt9C50L7QvNC60LAuINCf0YDQvtC80L4t0LLRltC00LXQvi4g0JLQtdC00LXQvdC90Y9cbi8vICAgICAgICAgICAgICAgICDRgdC+0YYt0LzQtdGA0LXQti5cbi8vICAgICAgICAgICAgICAgPC9wPlxuLy8gICAgICAgICAgICAgPC9kaXY+XG4vLyAgICAgICAgICAgPC9kaXY+XG4vLyAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzY3JvbGxUbygnI3Byb2plY3REYXRhSWQnKX0+XG4vLyAgICAgICAgICAgICA8aW1nIHNyYz17cHJvamVjQ2hlY2tEb3dufSBhbHQ9J3Byb2plY0NoZWNrRG93bicgLz5cbi8vICAgICAgICAgICA8L2J1dHRvbj5cbi8vICAgICAgICAgPC9kaXY+XG4vLyAgICAgICA8L2hlYWRlcj5cbi8vICAgICAgIDxzZWN0aW9uIGlkPXsncHJvamVjdERhdGFJZCd9IGNsYXNzTmFtZT17c3R5bGUucHJvamVjdF9kYXRhfT5cbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NvbnRhaW5lcic+XG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLmFib3V0fT5cbi8vICAgICAgICAgICAgIDxoMz7Qn9GA0L4g0LrQvtC80L/QsNC90ZbRjjwvaDM+XG4vLyAgICAgICAgICAgICA8cD5cbi8vICAgICAgICAgICAgICAg0KHRgtGD0LTRltGPINCw0YDRgtGW0YXQtdC60YLRg9GA0Lgg0ZYg0LTQuNC30LDQudC90YMg0ZbQvdGC0LXRgOKAmdGU0YDRgyDQndCw0YLQsNC70ZbRlyDQk9GD0LHQuNGIINGDINCb0YzQstC+0LLRli5cbi8vICAgICAgICAgICAgICAg0JrQvtC80L/QsNC90ZbRjyDRgNC+0LfRgNC+0LHQu9GP0ZQg0ZYg0YDQtdCw0LvRltC30L7QstGD0ZQg0LTQuNC30LDQudC9INC20LjRgtC70L7QstC40YUg0YLQsCDRltC90YjQuNGFXG4vLyAgICAgICAgICAgICAgINC/0YDQvtGB0YLQvtGA0ZbQsiwg0YjQuNGA0L7QutC+INGB0L/QtdGG0ZbQsNC70ZbQt9GD0ZTRgtGM0YHRjyDQvdCwINGE0YPQvdC60YbRltC+0L3QsNC70YzQvdC+0LzRgyDRltC90YLQtdGA4oCZ0ZTRgNGWINGWXG4vLyAgICAgICAgICAgICAgINC90LDQtNCw0ZQg0YHQstC+0Zcg0L/QvtGB0LvRg9Cz0Lgg0L3QtSDQu9C40YjQtSDRgyDQm9GM0LLQvtCy0ZYsINCwINGDINCx0YPQtNGMINGP0LrRgyDRgtC+0YfQutGDINGB0LLRltGC0YMuXG4vLyAgICAgICAgICAgICA8L3A+XG4vLyAgICAgICAgICAgPC9kaXY+XG4vLyAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLnRhc2tzfT5cbi8vICAgICAgICAgICAgIDxoMz7Ql9Cw0LTQsNGH0ZY8L2gzPlxuLy8gICAgICAgICAgICAgPHVsPlxuLy8gICAgICAgICAgICAgICB7dGFza3MubWFwKCh0KSA9PiAoXG4vLyAgICAgICAgICAgICAgICAgPGxpIGtleT17dH0+wrcge3R9PC9saT5cbi8vICAgICAgICAgICAgICAgKSl9XG4vLyAgICAgICAgICAgICA8L3VsPlxuLy8gICAgICAgICAgIDwvZGl2PlxuLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS5yZXN1bHRzfT5cbi8vICAgICAgICAgICAgIDxoMz7QoNC10LfRg9C70YzRgtCw0YLQuDwvaDM+XG4vLyAgICAgICAgICAgICA8dWw+XG4vLyAgICAgICAgICAgICAgIDxsaT5cbi8vICAgICAgICAgICAgICAgICA8YSBocmVmPScjJz5odWJ5c2guY29tPC9hPlxuLy8gICAgICAgICAgICAgICA8L2xpPlxuLy8gICAgICAgICAgICAgICA8bGk+XG4vLyAgICAgICAgICAgICAgICAgPGEgaHJlZj0nIyc+QG5hdGFsaWh1YnlzaDwvYT5cbi8vICAgICAgICAgICAgICAgPC9saT5cbi8vICAgICAgICAgICAgIDwvdWw+XG4vLyAgICAgICAgICAgPC9kaXY+XG4vLyAgICAgICAgIDwvZGl2PlxuLy8gICAgICAgPC9zZWN0aW9uPlxuLy8gICAgIDwvPlxuLy8gICApXG4vLyB9XG5cbi8vIGV4cG9ydCBkZWZhdWx0IFByb2plY3RQYWdlXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB1c2VTbW9vdGhTY3JvbGwgZnJvbSAncmVhY3Qtc21vb3RoLXNjcm9sbC1ob29rJ1xuZXhwb3J0IGNvbnN0IERlbW8gPSAoKSA9PiB7XG4gIC8vIEEgY3VzdG9tIHNjcm9sbCBjb250YWluZXJcbi8vICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpXG5cbiAgLy8gQWxzbyBzdXBwb3J0IGRvY3VtZW50LmJvZHkgLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGFuZCB5b3UgZG9uJ3QgbmVlZCB0byBzZXQgYSByZWYgcGFzc2luZyB0byBqc3hcbiAgY29uc3QgcmVmID0gdXNlUmVmKGRvY3VtZW50LmJvZHkpXG5cbiAgY29uc3QgeyBzY3JvbGxUbyB9ID0gdXNlU21vb3RoU2Nyb2xsKHtcbiAgICByZWYsXG4gICAgc3BlZWQ6IDEwMCxcbiAgICBkaXJlY3Rpb246ICd5J1xuICB9KVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2Nyb2xsVG8oJyNpdGVtLTIwJyl9PnNjcm9sbFRvKCcjaXRlbS0yMCcpPC9idXR0b24+XG4gICAgICA8ZGl2XG4gICAgICAgIC8vIGlmIHVzZSBjdXN0b20gc2Nyb2xsIGNvbnRhaW5lciwgcGFzcyByZWZcbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgb3ZlcmZsb3dZOiAnc2Nyb2xsJyxcbiAgICAgICAgICBtYXhIZWlnaHQ6ICcyMDBweCdcbiAgICAgICAgfX0+XG4gICAgICAgIHtBcnJheSgxMDApXG4gICAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgICAubWFwKChfaXRlbSwgaSkgPT4gKFxuICAgICAgICAgICAgPGRpdiBrZXk9e2l9IGlkPXtgaXRlbS0ke2l9YH0+XG4gICAgICAgICAgICAgIGl0ZW0te2l9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvPlxuICApXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/project/[id].tsx\n");

/***/ })

})